---
title: 'Optimize Jetpack Compose Recomposition'
description: 'Techniques để giảm unnecessary recomposition và improve UI performance'
pubDate: 2025-01-08
author: 'Khoi Van'
category: 'engineering'
tags: ['android', 'jetpack-compose', 'performance']
mood: 'technical'
---

import Callout from '../../components/mdx/Callout.astro'
import Comparison from '../../components/mdx/Comparison.astro'
import CodeDemo from '../../components/mdx/CodeDemo.astro'

Compose recomposition nhiều quá = UI lag. Đây là cách fix.

## Enable Layout Inspector

<CodeDemo title="Debug Recomposition">
```kotlin
// Enable in debug builds
if (BuildConfig.DEBUG) {
    System.setProperty(
        "kotlinx.coroutines.debug", 
        "on"
    )
}
```
</CodeDemo>

Android Studio → Tools → Layout Inspector → Show Recomposition Count

<Callout type="info">
Màu đỏ = recompose nhiều. Màu xanh = ổn.
</Callout>

## Key Optimization Techniques

### 1. Stable Types

<Comparison>
  <div slot="before">
```kotlin
// ❌ Unstable - recomposes always
data class User(
    val name: String,
    val posts: List<Post> // List is unstable
)

@Composable
fun UserCard(user: User) {
    // Recomposes even if user unchanged
}
```
  </div>
  <div slot="after">
```kotlin
// ✅ Stable with immutable collections
@Immutable
data class User(
    val name: String,
    val posts: ImmutableList<Post>
)

@Composable
fun UserCard(user: User) {
    // Skips recomposition if same
}
```
  </div>
</Comparison>

### 2. Remember Calculations

<Comparison>
  <div slot="before">
```kotlin
@Composable
fun ExpensiveList(items: List<Item>) {
    // ❌ Filters on every recomposition
    val filtered = items.filter { 
        it.price > 100 
    }
    LazyColumn {
        items(filtered) { item ->
            ItemCard(item)
        }
    }
}
```
  </div>
  <div slot="after">
```kotlin
@Composable
fun ExpensiveList(items: List<Item>) {
    // ✅ Remembers filtered list
    val filtered = remember(items) {
        items.filter { it.price > 100 }
    }
    LazyColumn {
        items(filtered, key = { it.id }) {
            ItemCard(it)
        }
    }
}
```
  </div>
</Comparison>

### 3. Lambda Optimization

<CodeDemo title="Avoid Lambda Allocation">
```kotlin
@Composable
fun MyScreen(viewModel: MyViewModel) {
    val onClick = remember(viewModel) {
        { item: Item -> viewModel.onItemClick(item) }
    }
    
    ItemList(
        items = viewModel.items,
        onClick = onClick // Stable reference
    )
}
```
</CodeDemo>

<Callout type="warning" title="Common Mistake">
Passing `{ viewModel.doSomething() }` directly creates new lambda every recomposition!
</Callout>

## Advanced: derivedStateOf

<CodeDemo title="Derive State Efficiently">
```kotlin
@Composable
fun SearchScreen() {
    var query by remember { mutableStateOf("") }
    val items = remember { getAllItems() }
    
    // Only recomputes when query changes
    val filtered by remember {
        derivedStateOf {
            if (query.isEmpty()) items
            else items.filter { 
                it.name.contains(query, ignoreCase = true) 
            }
        }
    }
    
    SearchResults(filtered)
}
```
</CodeDemo>

## Performance Metrics

<Callout type="success">
Sau khi optimize: 60% ít recomposition, UI smooth từ 45fps → 60fps trên mid-range devices.
</Callout>

## Quick Wins

1. **@Stable** hoặc **@Immutable** cho data classes
2. **remember { }** cho expensive operations
3. **key** parameter trong LazyColumn items
4. **derivedStateOf** cho computed values
5. **R8** full mode để optimize further

<CodeDemo title="Enable R8 Full Mode">
```properties
# gradle.properties
android.enableR8.fullMode=true
```
</CodeDemo>