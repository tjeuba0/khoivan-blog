---
title: 'Building Modern Android Apps in 2025: Jetpack Compose và Clean Architecture'
description: 'Hướng dẫn chi tiết về cách xây dựng ứng dụng Android hiện đại với Jetpack Compose, Clean Architecture, và các best practices mới nhất'
pubDate: 2025-01-09
author: 'Khoi Van'
category: 'engineering'
tags: ['android', 'jetpack-compose', 'clean-architecture', 'kotlin']
mood: 'technical'
featured: true
language: 'vi'
---

import { YouTube } from '@astro-community/astro-embed-youtube'
import { Tweet } from '@astro-community/astro-embed-twitter'

Sau 8 năm làm việc với Android development, tôi đã chứng kiến sự thay đổi lớn của ecosystem. Từ những ngày đầu với Java và XML layouts, đến Kotlin và giờ là Jetpack Compose. Hôm nay, tôi muốn chia sẻ kinh nghiệm xây dựng một ứng dụng Android hiện đại.

## Table of contents

<details>
<summary>Click to expand</summary>

- [Tại sao Jetpack Compose?](#tại-sao-jetpack-compose)
- [Clean Architecture trong Android](#clean-architecture-trong-android)
- [Setup Project](#setup-project)
- [Best Practices](#best-practices)
- [Performance Tips](#performance-tips)

</details>

## Tại sao Jetpack Compose?

Jetpack Compose đã thay đổi hoàn toàn cách chúng ta xây dựng UI trong Android. Không còn XML layouts, không còn findViewById, mọi thứ đều là Kotlin code.

```kotlin
@Composable
fun UserProfile(
    user: User,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier
            .fillMaxWidth()
            .padding(16.dp),
        elevation = CardDefaults.cardElevation(
            defaultElevation = 4.dp
        )
    ) {
        Row(
            modifier = Modifier.padding(16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            AsyncImage(
                model = user.avatarUrl,
                contentDescription = "Avatar",
                modifier = Modifier
                    .size(64.dp)
                    .clip(CircleShape)
            )
            
            Spacer(modifier = Modifier.width(16.dp))
            
            Column {
                Text(
                    text = user.name,
                    style = MaterialTheme.typography.headlineSmall
                )
                Text(
                    text = user.email,
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
        }
    }
}
```

### So sánh với XML

Trước đây với XML:
- 2 files riêng biệt (XML + Kotlin/Java)
- Khó maintain và refactor
- Runtime errors với findViewById
- Boilerplate code nhiều

Với Compose:
- Single source of truth
- Type-safe
- Preview trực tiếp trong Android Studio
- Reactive by default

## Clean Architecture trong Android

Clean Architecture giúp chúng ta tách biệt business logic khỏi framework dependencies. Đây là structure tôi thường dùng:

```
app/
├── data/
│   ├── repository/
│   ├── datasource/
│   │   ├── local/
│   │   └── remote/
│   └── model/
├── domain/
│   ├── model/
│   ├── repository/
│   └── usecase/
└── presentation/
    ├── ui/
    │   ├── screen/
    │   └── component/
    └── viewmodel/
```

### Domain Layer

Domain layer là trung tâm của architecture, không phụ thuộc vào bất kỳ framework nào:

```kotlin
// Domain model
data class Transaction(
    val id: String,
    val amount: BigDecimal,
    val type: TransactionType,
    val createdAt: Instant,
    val description: String
)

// Repository interface
interface TransactionRepository {
    suspend fun getTransactions(): Flow<List<Transaction>>
    suspend fun createTransaction(transaction: Transaction): Result<Transaction>
}

// Use case
class GetTransactionsUseCase(
    private val repository: TransactionRepository
) {
    operator fun invoke(): Flow<List<Transaction>> {
        return repository.getTransactions()
            .map { transactions ->
                transactions.sortedByDescending { it.createdAt }
            }
    }
}
```

## Setup Project

Đây là video hướng dẫn setup một project Android mới với best practices:

<YouTube id="dQw4w9WgXcQ" />

### Dependencies cần thiết

```kotlin
// build.gradle.kts (Module)
dependencies {
    // Compose BOM
    implementation(platform("androidx.compose:compose-bom:2024.02.00"))
    implementation("androidx.compose.ui:ui")
    implementation("androidx.compose.ui:ui-tooling-preview")
    implementation("androidx.compose.material3:material3")
    
    // Architecture Components
    implementation("androidx.lifecycle:lifecycle-viewmodel-compose:2.7.0")
    implementation("androidx.hilt:hilt-navigation-compose:1.1.0")
    
    // Hilt
    implementation("com.google.dagger:hilt-android:2.48")
    kapt("com.google.dagger:hilt-compiler:2.48")
    
    // Networking
    implementation("com.squareup.retrofit2:retrofit:2.9.0")
    implementation("com.squareup.okhttp3:logging-interceptor:4.12.0")
    
    // Coroutines
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3")
}
```

## Best Practices

### 1. State Management

Sử dụng `StateFlow` và `collectAsStateWithLifecycle`:

```kotlin
@HiltViewModel
class HomeViewModel @Inject constructor(
    private val getTransactionsUseCase: GetTransactionsUseCase
) : ViewModel() {
    
    private val _uiState = MutableStateFlow(HomeUiState())
    val uiState: StateFlow<HomeUiState> = _uiState.asStateFlow()
    
    init {
        loadTransactions()
    }
    
    private fun loadTransactions() {
        viewModelScope.launch {
            getTransactionsUseCase()
                .catch { _uiState.update { it.copy(error = true) } }
                .collect { transactions ->
                    _uiState.update { 
                        it.copy(
                            transactions = transactions,
                            loading = false
                        )
                    }
                }
        }
    }
}
```

### 2. Navigation

Sử dụng Type-safe navigation với Compose Navigation:

```kotlin
@Serializable
data class TransactionDetail(val transactionId: String)

@Composable
fun AppNavigation() {
    val navController = rememberNavController()
    
    NavHost(
        navController = navController,
        startDestination = Home
    ) {
        composable<Home> {
            HomeScreen(
                onTransactionClick = { transaction ->
                    navController.navigate(
                        TransactionDetail(transaction.id)
                    )
                }
            )
        }
        
        composable<TransactionDetail> { backStackEntry ->
            val detail: TransactionDetail = backStackEntry.toRoute()
            TransactionDetailScreen(
                transactionId = detail.transactionId,
                onBack = { navController.popBackStack() }
            )
        }
    }
}
```

## Performance Tips

### 1. Remember và Keys

Luôn sử dụng `remember` cho expensive computations:

```kotlin
@Composable
fun TransactionList(transactions: List<Transaction>) {
    val groupedTransactions = remember(transactions) {
        transactions.groupBy { 
            it.createdAt.toLocalDate() 
        }
    }
    
    LazyColumn {
        groupedTransactions.forEach { (date, dayTransactions) ->
            stickyHeader(key = date) {
                DateHeader(date = date)
            }
            
            items(
                items = dayTransactions,
                key = { it.id } // Important for performance
            ) { transaction ->
                TransactionItem(transaction = transaction)
            }
        }
    }
}
```

### 2. Baseline Profiles

Tạo Baseline Profiles để improve app startup time:

```kotlin
@ExperimentalBaselineProfilesApi
@RunWith(AndroidJUnit4::class)
class BaselineProfileGenerator {
    @get:Rule
    val rule = BaselineProfileRule()
    
    @Test
    fun generate() = rule.collect(
        packageName = "com.khoivan.myapp",
        maxIterations = 3,
        stableIterations = 2,
        outputFilePrefix = "baseline"
    ) {
        pressHome()
        startActivityAndWait()
        
        // Navigate through critical user journeys
        device.findObject(By.text("Login")).click()
        // ... more interactions
    }
}
```

## Real-world Example

Đây là một tweet về architecture pattern tôi đã implement trong production app:

<Tweet id="1234567890" />

### Multi-module Structure

Trong các dự án lớn, tôi thường chia thành multiple modules:

```
project/
├── app/                    # Main application module
├── core/
│   ├── common/            # Shared utilities
│   ├── network/           # Networking setup
│   ├── database/          # Room database
│   └── ui/                # Design system components
├── feature/
│   ├── login/             # Login feature
│   ├── home/              # Home feature
│   └── transaction/       # Transaction feature
└── buildSrc/              # Build configuration
```

Mỗi feature module có structure riêng:

```kotlin
// feature/transaction/build.gradle.kts
android {
    namespace = "com.khoivan.feature.transaction"
}

dependencies {
    implementation(project(":core:common"))
    implementation(project(":core:ui"))
    implementation(project(":core:network"))
    
    // Feature specific dependencies
}
```

## Testing Strategy

### Unit Tests cho ViewModels

```kotlin
@Test
fun `when load transactions success, should update ui state`() = runTest {
    // Given
    val transactions = listOf(mockTransaction())
    coEvery { getTransactionsUseCase() } returns flowOf(transactions)
    
    // When
    val viewModel = HomeViewModel(getTransactionsUseCase)
    
    // Then
    viewModel.uiState.test {
        val state = awaitItem()
        assertThat(state.transactions).isEqualTo(transactions)
        assertThat(state.loading).isFalse()
    }
}
```

### UI Tests với Compose

```kotlin
@Test
fun transactionList_displaysCorrectly() {
    composeTestRule.setContent {
        TransactionList(
            transactions = sampleTransactions
        )
    }
    
    composeTestRule
        .onNodeWithText("Coffee")
        .assertIsDisplayed()
    
    composeTestRule
        .onNodeWithText("-$5.00")
        .assertIsDisplayed()
}
```

## Kết luận

Android development đã tiến hóa rất nhiều trong những năm qua. Với Jetpack Compose và Clean Architecture, chúng ta có thể xây dựng những ứng dụng không chỉ đẹp mà còn maintainable và scalable.

Những key takeaways:
- **Jetpack Compose** giúp UI development nhanh và dễ hơn
- **Clean Architecture** tách biệt concerns và improve testability
- **Multi-module** approach giúp scale team và codebase
- **Performance** optimization từ đầu sẽ tiết kiệm thời gian sau này

Bạn có câu hỏi nào về Android development? Hãy comment bên dưới hoặc kết nối với tôi trên [Twitter](https://twitter.com/khoivan) để thảo luận thêm!

---

*Đây là bài viết trong series "Modern Android Development". Bài tiếp theo sẽ deep dive vào Kotlin Coroutines và Flow.*